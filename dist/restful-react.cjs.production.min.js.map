{"version":3,"file":"restful-react.cjs.production.min.js","sources":["../node_modules/regenerator-runtime/runtime.js","../src/Context.tsx","../src/util/composeUrl.ts","../src/util/parseError.ts","../src/util/processResponse.ts","../src/util/resolveData.ts","../src/util/constructUrl.tsx","../src/Get.tsx","../src/Poll.tsx","../src/Mutate.tsx","../src/util/useDeepCompareEffect.ts","../src/useAbort.ts","../src/useGet.tsx","../src/useMutate.tsx"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) });\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: true });\n  defineProperty(\n    GeneratorFunctionPrototype,\n    \"constructor\",\n    { value: GeneratorFunction, configurable: true }\n  );\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    defineProperty(this, \"_invoke\", { value: enqueue });\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(val) {\n    var object = Object(val);\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import noop from \"lodash/noop\";\nimport * as React from \"react\";\nimport { IStringifyOptions } from \"qs\";\nimport { ResolveFunction } from \"./Get\";\n\nexport interface RestfulReactProviderProps<TData = any> {\n  /** The backend URL where the RESTful resources live. */\n  base: string;\n  /**\n   * The path that gets accumulated from each level of nesting\n   * taking the absolute and relative nature of each path into consideration\n   */\n  parentPath?: string;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: ResolveFunction<TData>;\n  /**\n   * Options passed to the fetch request.\n   */\n  requestOptions?:\n    | (<TRequestBody>(\n        url: string,\n        method: string,\n        requestBody?: TRequestBody,\n      ) => Partial<RequestInit> | Promise<Partial<RequestInit>>)\n    | Partial<RequestInit>;\n  /**\n   * Trigger on each error.\n   * For `Get` and `Mutation` calls, you can also call `retry` to retry the exact same request.\n   * Please note that it's quite hard to retrieve the response data after a retry mutation in this case.\n   * Depending on your case, it can be easier to add a `localErrorOnly` on your `Mutate` component\n   * to deal with your retry locally instead of in the provider scope.\n   */\n  onError?: (\n    err: {\n      message: string;\n      data: TData | string;\n      status?: number;\n    },\n    retry: () => Promise<TData | null>,\n    response?: Response,\n  ) => void;\n  /**\n   * Trigger on each request\n   */\n  onRequest?: (req: Request) => void;\n  /**\n   * Trigger on each response\n   */\n  onResponse?: (res: Response) => void;\n  /**\n   * Any global level query params?\n   * **Warning:** it's probably not a good idea to put API keys here. Consider headers instead.\n   */\n  queryParams?: { [key: string]: any };\n  /**\n   * Query parameter stringify options applied for each request.\n   */\n  queryParamStringifyOptions?: IStringifyOptions;\n\n  children?: React.ReactNode | React.ReactNode[];\n}\n\nexport const Context = React.createContext<Required<RestfulReactProviderProps>>({\n  base: \"\",\n  parentPath: \"\",\n  resolve: (data: any) => data,\n  requestOptions: {},\n  onError: noop,\n  onRequest: noop,\n  onResponse: noop,\n  queryParams: {},\n  queryParamStringifyOptions: {},\n  children: null,\n});\n\nexport interface InjectedProps {\n  onError: RestfulReactProviderProps[\"onError\"];\n  onRequest: RestfulReactProviderProps[\"onRequest\"];\n  onResponse: RestfulReactProviderProps[\"onResponse\"];\n}\n\nexport default class RestfulReactProvider<T> extends React.Component<RestfulReactProviderProps<T>> {\n  public static displayName = \"RestfulProviderContext\";\n\n  public render() {\n    const { children, ...value } = this.props;\n    return (\n      <Context.Provider\n        value={{\n          onError: noop,\n          onRequest: noop,\n          onResponse: noop,\n          resolve: (data: any) => data,\n          requestOptions: {},\n          parentPath: \"\",\n          queryParams: {},\n          queryParamStringifyOptions: {},\n          children: null,\n          ...value,\n        }}\n      >\n        {children}\n      </Context.Provider>\n    );\n  }\n}\n\nexport const RestfulReactConsumer = Context.Consumer;\n","import url from \"url\";\n\nexport const composeUrl = (base: string = \"\", parentPath: string = \"\", path: string = \"\"): string => {\n  const composedPath = composePath(parentPath, path);\n  /* If the base is empty, preceding slash will be trimmed during composition */\n  if (base === \"\" && composedPath.startsWith(\"/\")) {\n    return composedPath;\n  }\n\n  /* If the base contains a trailing slash, it will be trimmed during composition */\n  return base!.endsWith(\"/\") ? `${base!.slice(0, -1)}${composedPath}` : `${base}${composedPath}`;\n};\n\n/**\n * If the path starts with slash, it is considered as absolute url.\n * If not, it is considered as relative url.\n * For example,\n * parentPath = \"/someBasePath\" and path = \"/absolute\" resolves to \"/absolute\"\n * whereas,\n * parentPath = \"/someBasePath\" and path = \"relative\" resolves to \"/someBasePath/relative\"\n */\nexport const composePath = (parentPath: string = \"\", path: string = \"\"): string => {\n  if (path.startsWith(\"/\") && path.length > 1) {\n    return url.resolve(parentPath, path);\n  } else if (path !== \"\" && path !== \"/\") {\n    return `${parentPath}/${path}`;\n  } else {\n    return parentPath;\n  }\n};\n","export const parseError = (e: any) => {\n  const msg = parseErrorMessage(e);\n  return {\n    message: msg,\n    data: e as any,\n  };\n};\n\nexport const parseErrorMessage = (e: any) => {\n  let errMessage = \"Failed to fetch, unknown error\";\n\n  if (e instanceof Error) {\n    errMessage = `Failed to fetch: ${getErrorMessage(e)}`;\n  }\n  return errMessage;\n};\n\nexport const getErrorMessage = (e: any) => {\n  let errMessage = \"unknown error\";\n\n  if (e instanceof Error) {\n    errMessage = `${e.message}`;\n  }\n  return errMessage;\n};\n","import { parseErrorMessage } from \"./parseError\";\n\nexport const processResponse = async (response: Response) => {\n  if (response.status === 204) {\n    return { data: undefined, responseError: false };\n  }\n  if ((response.headers.get(\"content-type\") || \"\").includes(\"application/json\")) {\n    try {\n      return {\n        data: await response.json(),\n        responseError: false,\n      };\n    } catch (e) {\n      return {\n        data: parseErrorMessage(e),\n        responseError: true,\n      };\n    }\n  } else if (\n    (response.headers.get(\"content-type\") || \"\").includes(\"text/plain\") ||\n    (response.headers.get(\"content-type\") || \"\").includes(\"text/html\")\n  ) {\n    try {\n      return {\n        data: await response.text(),\n        responseError: false,\n      };\n    } catch (e) {\n      return {\n        data: parseErrorMessage(e),\n        responseError: true,\n      };\n    }\n  } else {\n    return {\n      data: response,\n      responseError: false,\n    };\n  }\n};\n","import { GetDataError, ResolveFunction } from \"../types\";\n\nexport const resolveData = async <TData, TError>({\n  data,\n  resolve,\n}: {\n  data: any;\n  resolve?: ResolveFunction<TData>;\n}): Promise<{ data: TData | null; error: GetDataError<TError> | null }> => {\n  let resolvedData: TData | null = null;\n  let resolveError: GetDataError<TError> | null = null;\n  try {\n    if (resolve) {\n      const resolvedDataOrPromise: TData | Promise<TData> = resolve(data);\n      resolvedData = (resolvedDataOrPromise as { then?: any }).then\n        ? ((await resolvedDataOrPromise) as TData)\n        : (resolvedDataOrPromise as TData);\n    } else {\n      resolvedData = data;\n    }\n  } catch (err) {\n    resolvedData = null;\n    resolveError = {\n      message: \"RESOLVE_ERROR\",\n      data: JSON.stringify(err),\n    };\n  }\n  return {\n    data: resolvedData,\n    error: resolveError,\n  };\n};\n","import qs, { IStringifyOptions } from \"qs\";\nimport url from \"url\";\n\ntype ResolvePathOptions = {\n  queryParamOptions?: IStringifyOptions;\n  stripTrailingSlash?: boolean;\n};\n\nexport function constructUrl<TQueryParams>(\n  base: string,\n  path: string,\n  queryParams?: TQueryParams,\n  resolvePathOptions: ResolvePathOptions = {},\n) {\n  const { queryParamOptions, stripTrailingSlash } = resolvePathOptions;\n\n  const normalizedBase = base.endsWith(\"/\") ? base : `${base}/`;\n  const trimmedPath = path.startsWith(\"/\") ? path.slice(1) : path;\n\n  const encodedPathWithParams = Object.keys(queryParams || {}).length\n    ? `${trimmedPath}?${qs.stringify(queryParams, queryParamOptions)}`\n    : trimmedPath;\n\n  const composed = Boolean(encodedPathWithParams) ? url.resolve(normalizedBase, encodedPathWithParams) : normalizedBase;\n\n  return stripTrailingSlash && composed.endsWith(\"/\") ? composed.slice(0, -1) : composed;\n}\n","import { DebounceSettings } from \"lodash\";\nimport debounce from \"lodash/debounce\";\nimport isEqual from \"lodash/isEqual\";\nimport * as React from \"react\";\n\nimport RestfulReactProvider, { InjectedProps, RestfulReactConsumer, RestfulReactProviderProps } from \"./Context\";\nimport { composePath, composeUrl } from \"./util/composeUrl\";\nimport { processResponse } from \"./util/processResponse\";\nimport { resolveData } from \"./util/resolveData\";\nimport { constructUrl } from \"./util/constructUrl\";\nimport { IStringifyOptions } from \"qs\";\nimport { parseError } from \"./util/parseError\";\n\n/**\n * A function that resolves returned data from\n * a fetch call.\n */\nexport type ResolveFunction<TData> = (data: any) => TData;\n\nexport interface GetDataError<TError> {\n  message: string;\n  data: TError | string;\n  status?: number;\n}\n\n/**\n * An enumeration of states that a fetchable\n * view could possibly have.\n */\nexport interface States<TData, TError> {\n  /** Is our view currently loading? */\n  loading: boolean;\n  /** Do we have an error in the view? */\n  error?: GetState<TData, TError>[\"error\"];\n}\n\nexport type GetMethod<TData> = () => Promise<TData | null>;\n\n/**\n * An interface of actions that can be performed\n * within Get\n */\nexport interface Actions<TData> {\n  /** Refetches the same path */\n  refetch: GetMethod<TData>;\n}\n\n/**\n * Meta information returned to the fetchable\n * view.\n */\nexport interface Meta {\n  /** The entire response object passed back from the request. */\n  response: Response | null;\n  /** The absolute path of this request. */\n  absolutePath: string;\n}\n\n/**\n * Props for the <Get /> component.\n */\nexport interface GetProps<TData, TError, TQueryParams, TPathParams> {\n  /**\n   * The path at which to request data,\n   * typically composed by parent Gets or the RestfulProvider.\n   */\n  path: string;\n  /**\n   * @private This is an internal implementation detail in restful-react, not meant to be used externally.\n   * This helps restful-react correctly override `path`s when a new `base` property is provided.\n   */\n  __internal_hasExplicitBase?: boolean;\n  /**\n   * A function that recieves the returned, resolved\n   * data.\n   *\n   * @param data - data returned from the request.\n   * @param actions - a key/value map of HTTP verbs, aliasing destroy to DELETE.\n   */\n  children: (data: TData | null, states: States<TData, TError>, actions: Actions<TData>, meta: Meta) => React.ReactNode;\n  /** Options passed into the fetch call. */\n  requestOptions?: RestfulReactProviderProps[\"requestOptions\"];\n  /**\n   * Path parameters\n   */\n  pathParams?: TPathParams;\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Query parameter stringify options\n   */\n  queryParamStringifyOptions?: IStringifyOptions;\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: ResolveFunction<TData>;\n  /**\n   * Should we wait until we have data before rendering?\n   * This is useful in cases where data is available too quickly\n   * to display a spinner or some type of loading state.\n   */\n  wait?: boolean;\n  /**\n   * Should we fetch data at a later stage?\n   */\n  lazy?: boolean;\n  /**\n   * An escape hatch and an alternative to `path` when you'd like\n   * to fetch from an entirely different URL.\n   *\n   */\n  base?: string;\n  /**\n   * The accumulated path from each level of parent GETs\n   *  taking the absolute and relative nature of each path into consideration\n   */\n  parentPath?: string;\n  /**\n   * How long do we wait between subsequent requests?\n   * Uses [lodash's debounce](https://lodash.com/docs/4.17.10#debounce) under the hood.\n   */\n  debounce?:\n    | {\n        wait?: number;\n        options: DebounceSettings;\n      }\n    | boolean\n    | number;\n}\n\n/**\n * State for the <Get /> component. These\n * are implementation details and should be\n * hidden from any consumers.\n */\nexport interface GetState<TData, TError> {\n  data: TData | null;\n  response: Response | null;\n  error: GetDataError<TError> | null;\n  loading: boolean;\n}\n\n/**\n * The <Get /> component without Context. This\n * is a named class because it is useful in\n * debugging.\n */\nclass ContextlessGet<TData, TError, TQueryParams, TPathParams = unknown> extends React.Component<\n  GetProps<TData, TError, TQueryParams, TPathParams> & InjectedProps,\n  Readonly<GetState<TData, TError>>\n> {\n  constructor(props: GetProps<TData, TError, TQueryParams, TPathParams> & InjectedProps) {\n    super(props);\n\n    if (typeof props.debounce === \"object\") {\n      this.fetch = debounce(this.fetch, props.debounce.wait, props.debounce.options);\n    } else if (typeof props.debounce === \"number\") {\n      this.fetch = debounce(this.fetch, props.debounce);\n    } else if (props.debounce) {\n      this.fetch = debounce(this.fetch);\n    }\n  }\n\n  /**\n   * Abort controller to cancel the current fetch query\n   */\n  private abortController = new AbortController();\n  private signal = this.abortController.signal;\n\n  public readonly state: Readonly<GetState<TData, TError>> = {\n    data: null, // Means we don't _yet_ have data.\n    response: null,\n    loading: !this.props.lazy,\n    error: null,\n  };\n\n  public static defaultProps = {\n    base: \"\",\n    parentPath: \"\",\n    resolve: (unresolvedData: any) => unresolvedData,\n    queryParams: {},\n  };\n\n  public componentDidMount() {\n    if (!this.props.lazy) {\n      this.fetch();\n    }\n  }\n\n  public componentDidUpdate(prevProps: GetProps<TData, TError, TQueryParams, TPathParams>) {\n    const { base, parentPath, path, resolve, queryParams, requestOptions } = prevProps;\n    if (\n      base !== this.props.base ||\n      parentPath !== this.props.parentPath ||\n      path !== this.props.path ||\n      !isEqual(queryParams, this.props.queryParams) ||\n      // both `resolve` props need to _exist_ first, and then be equivalent.\n      (resolve && this.props.resolve && resolve.toString() !== this.props.resolve.toString()) ||\n      (requestOptions &&\n        this.props.requestOptions &&\n        requestOptions.toString() !== this.props.requestOptions.toString())\n    ) {\n      if (!this.props.lazy) {\n        this.fetch();\n      }\n    }\n  }\n\n  public componentWillUnmount() {\n    this.abortController.abort();\n  }\n\n  public getRequestOptions = async (\n    url: string,\n    extraOptions?: Partial<RequestInit>,\n    extraHeaders?: boolean | { [key: string]: string },\n  ) => {\n    const { requestOptions } = this.props;\n\n    if (typeof requestOptions === \"function\") {\n      const options = (await requestOptions(url, \"GET\")) || {};\n      return {\n        ...extraOptions,\n        ...options,\n        headers: new Headers({\n          ...(typeof extraHeaders !== \"boolean\" ? extraHeaders : {}),\n          ...(extraOptions || {}).headers,\n          ...options.headers,\n        }),\n      };\n    }\n\n    return {\n      ...extraOptions,\n      ...requestOptions,\n      headers: new Headers({\n        ...(typeof extraHeaders !== \"boolean\" ? extraHeaders : {}),\n        ...(extraOptions || {}).headers,\n        ...(requestOptions || {}).headers,\n      }),\n    };\n  };\n\n  public fetch = async (requestPath?: string, thisRequestOptions?: RequestInit) => {\n    const { base, __internal_hasExplicitBase, parentPath, path, resolve, onError, onRequest, onResponse } = this.props;\n\n    if (this.state.error || !this.state.loading) {\n      this.setState(() => ({ error: null, loading: true }));\n    }\n\n    const makeRequestPath = () => {\n      const concatPath = __internal_hasExplicitBase ? path : composePath(parentPath, path);\n\n      return constructUrl(base!, concatPath, this.props.queryParams, {\n        stripTrailingSlash: true,\n        queryParamOptions: this.props.queryParamStringifyOptions,\n      });\n    };\n\n    const request = new Request(makeRequestPath(), await this.getRequestOptions(makeRequestPath(), thisRequestOptions));\n    if (onRequest) onRequest(request);\n    try {\n      const response = await fetch(request, { signal: this.signal });\n      const originalResponse = response.clone();\n      if (onResponse) onResponse(response.clone());\n      const { data, responseError } = await processResponse(response);\n\n      // avoid state updates when component has been unmounted\n      if (this.signal.aborted) {\n        return;\n      }\n\n      if (!response.ok || responseError) {\n        const error = {\n          message: `Failed to fetch: ${response.status} ${response.statusText}${responseError ? \" - \" + data : \"\"}`,\n          data,\n          status: response.status,\n        };\n\n        this.setState({\n          loading: false,\n          error,\n          data: null,\n          response: originalResponse,\n        });\n\n        if (!this.props.localErrorOnly && onError) {\n          onError(error, () => this.fetch(requestPath, thisRequestOptions), response);\n        }\n\n        return null;\n      }\n\n      const resolved = await resolveData<TData, TError>({ data, resolve });\n\n      this.setState({ loading: false, data: resolved.data, error: resolved.error, response: originalResponse });\n      return data;\n    } catch (e) {\n      // avoid state updates when component has been unmounted\n      // and when fetch/processResponse threw an error\n      if (this.signal.aborted) {\n        return;\n      }\n\n      this.setState({\n        loading: false,\n        data: null,\n        error: parseError(e),\n      });\n    }\n  };\n\n  public render() {\n    const { children, wait, path, base, parentPath } = this.props;\n    const { data, error, loading, response } = this.state;\n\n    if (wait && data === null && !error) {\n      return <></>; // Show nothing until we have data.\n    }\n\n    return children(\n      data,\n      { loading, error },\n      { refetch: this.fetch },\n      { response, absolutePath: composeUrl(base!, parentPath!, path) },\n    );\n  }\n}\n\n/**\n * The <Get /> component _with_ context.\n * Context is used to compose path props,\n * and to maintain the base property against\n * which all requests will be made.\n *\n * We compose Consumers immediately with providers\n * in order to provide new `parentPath` props that contain\n * a segment of the path, creating composable URLs.\n */\nfunction Get<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>(\n  props: GetProps<TData, TError, TQueryParams, TPathParams>,\n) {\n  return (\n    <RestfulReactConsumer>\n      {contextProps => (\n        <RestfulReactProvider {...contextProps} parentPath={composePath(contextProps.parentPath, props.path)}>\n          <ContextlessGet\n            {...contextProps}\n            {...props}\n            queryParams={{ ...contextProps.queryParams, ...props.queryParams }}\n            __internal_hasExplicitBase={Boolean(props.base)}\n            queryParamStringifyOptions={{\n              ...contextProps.queryParamStringifyOptions,\n              ...props.queryParamStringifyOptions,\n            }}\n          />\n        </RestfulReactProvider>\n      )}\n    </RestfulReactConsumer>\n  );\n}\n\nexport default Get;\n","import merge from \"lodash/merge\";\nimport * as React from \"react\";\nimport equal from \"react-fast-compare\";\n\nimport { InjectedProps, RestfulReactConsumer } from \"./Context\";\nimport { GetProps, GetState, Meta as GetComponentMeta } from \"./Get\";\nimport { composeUrl } from \"./util/composeUrl\";\nimport { processResponse } from \"./util/processResponse\";\nimport { constructUrl } from \"./util/constructUrl\";\nimport { IStringifyOptions } from \"qs\";\n\n/**\n * Meta information returned from the poll.\n */\ninterface Meta extends GetComponentMeta {\n  /**\n   * The entire response object.\n   */\n  response: Response | null;\n}\n\n/**\n * States of the current poll\n */\ninterface States<TData, TError> {\n  /**\n   * Is the component currently polling?\n   */\n  polling: PollState<TData, TError>[\"polling\"];\n  /**\n   * Is the initial request loading?\n   */\n  loading: PollState<TData, TError>[\"loading\"];\n  /**\n   * Has the poll concluded?\n   */\n  finished: PollState<TData, TError>[\"finished\"];\n  /**\n   * Is there an error? What is it?\n   */\n  error: PollState<TData, TError>[\"error\"];\n}\n\n/**\n * Actions that can be executed within the\n * component.\n */\ninterface Actions {\n  start: () => void;\n  stop: () => void;\n}\n\n/**\n * Props that can control the Poll component.\n */\nexport interface PollProps<TData, TError, TQueryParams, TPathParams> {\n  /**\n   * What path are we polling on?\n   */\n  path: GetProps<TData, TError, TQueryParams, TPathParams>[\"path\"];\n  /**\n   * A function that gets polled data, the current\n   * states, meta information, and various actions\n   * that can be executed at the poll-level.\n   */\n  children: (data: TData | null, states: States<TData, TError>, actions: Actions, meta: Meta) => React.ReactNode;\n  /**\n   * How long do we wait between repeating a request?\n   * Value in milliseconds.\n   *\n   * Defaults to 1000.\n   */\n  interval?: number;\n  /**\n   * How long should a request stay open?\n   * Value in seconds.\n   *\n   * Defaults to 60.\n   */\n  wait?: number;\n  /**\n   * A stop condition for the poll that expects\n   * a boolean.\n   *\n   * @param data - The data returned from the poll.\n   * @param response - The full response object. This could be useful in order to stop polling when !response.ok, for example.\n   */\n  until?: (data: TData | null, response: Response | null) => boolean;\n  /**\n   * Are we going to wait to start the poll?\n   * Use this with { start, stop } actions.\n   */\n  lazy?: GetProps<TData, TError, TQueryParams, TPathParams>[\"lazy\"];\n  /**\n   * Should the data be transformed in any way?\n   */\n  resolve?: (data: any, prevData: TData | null) => TData;\n  /**\n   * We can request foreign URLs with this prop.\n   */\n  base?: GetProps<TData, TError, TQueryParams, TPathParams>[\"base\"];\n  /**\n   * Any options to be passed to this request.\n   */\n  requestOptions?: GetProps<TData, TError, TQueryParams, TPathParams>[\"requestOptions\"];\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Query parameter stringify options\n   */\n  queryParamStringifyOptions?: IStringifyOptions;\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n}\n\n/**\n * The state of the Poll component. This should contain\n * implementation details not necessarily exposed to\n * consumers.\n */\nexport interface PollState<TData, TError> {\n  /**\n   * Are we currently polling?\n   */\n  polling: boolean;\n  /**\n   * Have we finished polling?\n   */\n  finished: boolean;\n  /**\n   * What was the last response?\n   */\n  lastResponse: Response | null;\n  /**\n   * What data are we holding in here?\n   */\n  data: GetState<TData, TError>[\"data\"];\n  /**\n   * What data did we had before?\n   */\n  previousData: GetState<TData, TError>[\"data\"];\n  /**\n   * Are we loading?\n   */\n  loading: GetState<TData, TError>[\"loading\"];\n  /**\n   * Do we currently have an error?\n   */\n  error: GetState<TData, TError>[\"error\"];\n  /**\n   * Index of the last polled response.\n   */\n  lastPollIndex?: string;\n}\n\n/**\n * The <Poll /> component without context.\n */\nclass ContextlessPoll<TData, TError, TQueryParams, TPathParams = unknown> extends React.Component<\n  PollProps<TData, TError, TQueryParams, TPathParams> & InjectedProps,\n  Readonly<PollState<TData, TError>>\n> {\n  public readonly state: Readonly<PollState<TData, TError>> = {\n    data: null,\n    previousData: null,\n    loading: !this.props.lazy,\n    lastResponse: null,\n    polling: !this.props.lazy,\n    finished: false,\n    error: null,\n  };\n\n  public static defaultProps = {\n    interval: 1000,\n    wait: 60,\n    base: \"\",\n    resolve: (data: any) => data,\n    queryParams: {},\n  };\n\n  private keepPolling = !this.props.lazy;\n\n  /**\n   * Abort controller to cancel the current fetch query\n   */\n  private abortController = new AbortController();\n  private signal = this.abortController.signal;\n\n  private isModified = (response: Response, nextData: TData) => {\n    if (response.status === 304) {\n      return false;\n    }\n    if (equal(this.state.data, nextData)) {\n      return false;\n    }\n    return true;\n  };\n\n  private getRequestOptions = (url: string) =>\n    typeof this.props.requestOptions === \"function\"\n      ? this.props.requestOptions(url, \"GET\")\n      : this.props.requestOptions || {};\n\n  // 304 is not a OK status code but is green in Chrome 🤦🏾‍♂️\n  private isResponseOk = (response: Response) => response.ok || response.status === 304;\n\n  /**\n   * This thing does the actual poll.\n   */\n  public cycle = async () => {\n    // Have we stopped?\n    if (!this.keepPolling) {\n      return; // stop.\n    }\n\n    // Should we stop?\n    if (this.props.until && this.props.until(this.state.data, this.state.lastResponse)) {\n      this.stop(); // stop.\n      return;\n    }\n\n    // If we should keep going,\n    const { base, path, interval, wait, onError, onRequest, onResponse } = this.props;\n    const { lastPollIndex } = this.state;\n\n    const url = constructUrl(base!, path, this.props.queryParams, {\n      queryParamOptions: this.props.queryParamStringifyOptions,\n      stripTrailingSlash: true,\n    });\n\n    const requestOptions = await this.getRequestOptions(url);\n\n    const request = new Request(url, {\n      ...requestOptions,\n      headers: {\n        Prefer: `wait=${wait}s;${lastPollIndex ? `index=${lastPollIndex}` : \"\"}`,\n        ...requestOptions.headers,\n      },\n    });\n    if (onRequest) onRequest(request);\n\n    try {\n      const response = await fetch(request, { signal: this.signal });\n      if (onResponse) onResponse(response.clone());\n      const { data, responseError } = await processResponse(response);\n\n      if (!this.keepPolling || this.signal.aborted) {\n        // Early return if we have stopped polling or component was unmounted\n        // to avoid memory leaks\n        return;\n      }\n\n      if (!this.isResponseOk(response) || responseError) {\n        const error = {\n          message: `Failed to poll: ${response.status} ${response.statusText}${responseError ? \" - \" + data : \"\"}`,\n          data,\n          status: response.status,\n        };\n        this.setState({ loading: false, lastResponse: response, error });\n\n        if (!this.props.localErrorOnly && onError) {\n          onError(error, () => Promise.resolve(), response);\n        }\n      } else if (this.isModified(response, data)) {\n        this.setState(prevState => ({\n          loading: false,\n          lastResponse: response,\n          previousData: prevState.data,\n          data,\n          error: null,\n          lastPollIndex: response.headers.get(\"x-polling-index\") || undefined,\n        }));\n      }\n\n      // Wait for interval to pass.\n      await new Promise(resolvePromise => setTimeout(resolvePromise, interval));\n      this.cycle(); // Do it all again!\n    } catch (e) {\n      // the only error not catched is the `fetch`, this means that we have cancelled the fetch\n    }\n  };\n\n  public start = () => {\n    this.keepPolling = true;\n    if (!this.state.polling) {\n      this.setState(() => ({ polling: true })); // let everyone know we're done here.\n    }\n    this.cycle();\n  };\n\n  public stop = () => {\n    this.keepPolling = false;\n    this.setState(() => ({ polling: false, finished: true })); // let everyone know we're done here.\n  };\n\n  public componentDidMount() {\n    const { path, lazy } = this.props;\n\n    if (path === undefined) {\n      throw new Error(\n        `[restful-react]: You're trying to poll something without a path. Please specify a \"path\" prop on your Poll component.`,\n      );\n    }\n\n    if (!lazy) {\n      this.start();\n    }\n  }\n\n  public componentWillUnmount() {\n    // Cancel the current query\n    this.abortController.abort();\n\n    // Stop the polling cycle\n    this.stop();\n  }\n\n  public render() {\n    const { lastResponse: response, previousData, data, polling, loading, error, finished } = this.state;\n    const { children, base, path, resolve } = this.props;\n\n    const meta: Meta = {\n      response,\n      absolutePath: composeUrl(base!, \"\", path),\n    };\n\n    const states: States<TData, TError> = {\n      polling,\n      loading,\n      error,\n      finished,\n    };\n\n    const actions: Actions = {\n      stop: this.stop,\n      start: this.start,\n    };\n    // data is parsed only when poll has already resolved so response is defined\n    const resolvedData = response && resolve ? resolve(data, previousData) : data;\n    return children(resolvedData, states, actions, meta);\n  }\n}\n\nfunction Poll<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>(\n  props: PollProps<TData, TError, TQueryParams, TPathParams>,\n) {\n  // Compose Contexts to allow for URL nesting\n  return (\n    <RestfulReactConsumer>\n      {contextProps => {\n        return (\n          <ContextlessPoll\n            {...contextProps}\n            {...props}\n            queryParams={{ ...contextProps.queryParams, ...props.queryParams }}\n            requestOptions={async (url: string, method: string) => {\n              const contextRequestOptions =\n                typeof contextProps.requestOptions === \"function\"\n                  ? await contextProps.requestOptions(url, method)\n                  : contextProps.requestOptions || {};\n              const propsRequestOptions =\n                typeof props.requestOptions === \"function\"\n                  ? await props.requestOptions(url, method)\n                  : props.requestOptions || {};\n\n              return merge(contextRequestOptions, propsRequestOptions);\n            }}\n            queryParamStringifyOptions={{\n              ...contextProps.queryParamStringifyOptions,\n              ...props.queryParamStringifyOptions,\n            }}\n          />\n        );\n      }}\n    </RestfulReactConsumer>\n  );\n}\n\nexport default Poll;\n","import * as React from \"react\";\nimport RestfulReactProvider, { InjectedProps, RestfulReactConsumer, RestfulReactProviderProps } from \"./Context\";\nimport { GetState, ResolveFunction } from \"./Get\";\nimport { composePath, composeUrl } from \"./util/composeUrl\";\nimport { processResponse } from \"./util/processResponse\";\nimport { constructUrl } from \"./util/constructUrl\";\nimport { IStringifyOptions } from \"qs\";\nimport { parseError } from \"./util/parseError\";\n\n/**\n * An enumeration of states that a fetchable\n * view could possibly have.\n */\nexport interface States<TData, TError> {\n  /** Is our view currently loading? */\n  loading: boolean;\n  /** Do we have an error in the view? */\n  error?: GetState<TData, TError>[\"error\"];\n}\n\nexport interface MutateRequestOptions<TQueryParams, TPathParams> extends RequestInit {\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Path parameters\n   */\n  pathParams?: TPathParams;\n}\n\nexport type MutateMethod<TData, TRequestBody, TQueryParams, TPathParams> = (\n  data: TRequestBody,\n  mutateRequestOptions?: MutateRequestOptions<TQueryParams, TPathParams>,\n) => Promise<TData>;\n\n/**\n * Meta information returned to the fetchable\n * view.\n */\nexport interface Meta {\n  /** The absolute path of this request. */\n  absolutePath: string;\n}\n\n/**\n * Props for the <Mutate /> component.\n */\nexport interface MutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams> {\n  /**\n   * The path at which to request data,\n   * typically composed by parents or the RestfulProvider.\n   */\n  path?: string;\n  /**\n   * @private This is an internal implementation detail in restful-react, not meant to be used externally.\n   * This helps restful-react correctly override `path`s when a new `base` property is provided.\n   */\n  __internal_hasExplicitBase?: boolean;\n  /**\n   * What HTTP verb are we using?\n   */\n  verb: \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Query parameter stringify options\n   */\n  queryParamStringifyOptions?: IStringifyOptions;\n  /**\n   * An escape hatch and an alternative to `path` when you'd like\n   * to fetch from an entirely different URL.\n   *\n   */\n  base?: string;\n  /**\n   * The accumulated path from each level of parent GETs\n   *  taking the absolute and relative nature of each path into consideration\n   */\n  parentPath?: string;\n  /** Options passed into the fetch call. */\n  requestOptions?: RestfulReactProviderProps[\"requestOptions\"];\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n  /**\n   * A function that recieves a mutation function, along with\n   * some metadata.\n   *\n   * @param actions - a key/value map of HTTP verbs, aliasing destroy to DELETE.\n   */\n  children: (\n    mutate: MutateMethod<TData, TRequestBody, TQueryParams, TPathParams>,\n    states: States<TData, TError>,\n    meta: Meta,\n  ) => React.ReactNode;\n  /**\n   * Callback called after the mutation is done.\n   *\n   * @param body - Body given to mutate\n   * @param data - Response data\n   */\n  onMutate?: (body: TRequestBody, data: TData) => void;\n  /**\n   * A function to encode body of DELETE requests when appending it\n   * to an existing path\n   */\n  pathInlineBodyEncode?: typeof encodeURIComponent;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: ResolveFunction<TData>;\n}\n\n/**\n * State for the <Mutate /> component. These\n * are implementation details and should be\n * hidden from any consumers.\n */\nexport interface MutateState<TData, TError> {\n  error: GetState<TData, TError>[\"error\"];\n  loading: boolean;\n}\n\n/**\n * The <Mutate /> component without Context. This\n * is a named class because it is useful in\n * debugging.\n */\nclass ContextlessMutate<TData, TError, TQueryParams, TRequestBody, TPathParams> extends React.Component<\n  MutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams> & InjectedProps,\n  MutateState<TData, TError>\n> {\n  public readonly state: Readonly<MutateState<TData, TError>> = {\n    loading: false,\n    error: null,\n  };\n\n  public static defaultProps = {\n    base: \"\",\n    parentPath: \"\",\n    path: \"\",\n    queryParams: {},\n  };\n\n  /**\n   * Abort controller to cancel the current fetch query\n   */\n  private abortController = new AbortController();\n  private signal = this.abortController.signal;\n\n  public componentWillUnmount() {\n    this.abortController.abort();\n  }\n\n  public mutate = async (\n    body: TRequestBody,\n    mutateRequestOptions?: MutateRequestOptions<TQueryParams, TPathParams>,\n  ) => {\n    const {\n      __internal_hasExplicitBase,\n      base,\n      parentPath,\n      path,\n      verb,\n      requestOptions: providerRequestOptions,\n      onError,\n      onRequest,\n      onResponse,\n      pathInlineBodyEncode,\n      resolve,\n    } = this.props;\n    this.setState(() => ({ error: null, loading: true }));\n\n    const makeRequestPath = () => {\n      const pathWithPossibleBody =\n        verb === \"DELETE\" && typeof body === \"string\"\n          ? composePath(path, pathInlineBodyEncode ? pathInlineBodyEncode(body) : body)\n          : path;\n\n      const concatPath = __internal_hasExplicitBase\n        ? pathWithPossibleBody || \"\"\n        : composePath(parentPath, pathWithPossibleBody);\n\n      return constructUrl(base!, concatPath, this.props.queryParams, {\n        stripTrailingSlash: true,\n        queryParamOptions: this.props.queryParamStringifyOptions,\n      });\n    };\n\n    const request = new Request(makeRequestPath(), {\n      method: verb,\n      body: body instanceof FormData ? body : typeof body === \"object\" ? JSON.stringify(body) : body,\n      ...(typeof providerRequestOptions === \"function\"\n        ? await providerRequestOptions<TRequestBody>(makeRequestPath(), verb, body)\n        : providerRequestOptions),\n      ...mutateRequestOptions,\n      headers: {\n        ...(typeof providerRequestOptions === \"function\"\n          ? (await providerRequestOptions<TRequestBody>(makeRequestPath(), verb, body)).headers\n          : (providerRequestOptions || {}).headers),\n        ...(mutateRequestOptions ? mutateRequestOptions.headers : {}),\n      },\n    } as RequestInit); // Type assertion for version of TypeScript that can't yet discriminate.\n\n    // only set default content-type if body is not of type FormData and there is no content-type already defined on mutateRequestOptions.headers\n    if (!(body instanceof FormData) && !request.headers.has(\"content-type\")) {\n      request.headers.set(\"content-type\", typeof body === \"object\" ? \"application/json\" : \"text/plain\");\n    }\n\n    if (onRequest) onRequest(request);\n\n    let response: Response;\n    try {\n      response = await fetch(request, { signal: this.signal });\n      if (onResponse) onResponse(response.clone());\n    } catch (e) {\n      const error = parseError(e);\n      this.setState({\n        error,\n        loading: false,\n      });\n\n      if (!this.props.localErrorOnly && onError) {\n        onError(error, () => this.mutate(body, mutateRequestOptions));\n      }\n\n      throw error;\n    }\n\n    const { data: rawData, responseError } = await processResponse(response);\n\n    let data: TData | any; // `any` -> data in error case\n    try {\n      data = resolve ? resolve(rawData) : rawData;\n    } catch (e) {\n      if (this.signal.aborted) {\n        return;\n      }\n\n      this.setState({\n        error: parseError(e),\n        loading: false,\n      });\n      throw e;\n    }\n\n    // avoid state updates when component has been unmounted\n    if (this.signal.aborted) {\n      return;\n    }\n    if (!response.ok || responseError) {\n      const error = {\n        data,\n        message: `Failed to fetch: ${response.status} ${response.statusText}`,\n        status: response.status,\n      };\n\n      this.setState({\n        error,\n        loading: false,\n      });\n\n      if (!this.props.localErrorOnly && onError) {\n        onError(error, () => this.mutate(body, mutateRequestOptions), response);\n      }\n\n      throw error;\n    }\n\n    this.setState({ loading: false });\n\n    if (this.props.onMutate) {\n      this.props.onMutate(body, data);\n    }\n\n    return data;\n  };\n\n  public render() {\n    const { children, path, base, parentPath } = this.props;\n    const { error, loading } = this.state;\n\n    return children(this.mutate, { loading, error }, { absolutePath: composeUrl(base!, parentPath!, path!) });\n  }\n}\n\n/**\n * The <Mutate /> component _with_ context.\n * Context is used to compose path props,\n * and to maintain the base property against\n * which all requests will be made.\n *\n * We compose Consumers immediately with providers\n * in order to provide new `parentPath` props that contain\n * a segment of the path, creating composable URLs.\n */\nfunction Mutate<\n  TData = any,\n  TError = any,\n  TQueryParams = { [key: string]: any },\n  TRequestBody = any,\n  TPathParams = unknown\n>(props: MutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>) {\n  return (\n    <RestfulReactConsumer>\n      {contextProps => (\n        <RestfulReactProvider {...contextProps} parentPath={composePath(contextProps.parentPath, props.path!)}>\n          <ContextlessMutate<TData, TError, TQueryParams, TRequestBody, TPathParams>\n            {...contextProps}\n            {...props}\n            queryParams={{ ...contextProps.queryParams, ...props.queryParams } as TQueryParams}\n            queryParamStringifyOptions={{\n              ...contextProps.queryParamStringifyOptions,\n              ...props.queryParamStringifyOptions,\n            }}\n            __internal_hasExplicitBase={Boolean(props.base)}\n          />\n        </RestfulReactProvider>\n      )}\n    </RestfulReactConsumer>\n  );\n}\n\nexport default Mutate;\n","import isEqualWith from \"lodash/isEqualWith\";\nimport React, { useCallback, useEffect, useRef } from \"react\";\n\n/**\n * Custom version of isEqual to handle function comparison\n */\nconst isEqual = (x: any, y: any) =>\n  isEqualWith(x, y, (a, b) => {\n    // Deal with the function comparison case\n    if (typeof a === \"function\" && typeof b === \"function\") {\n      return a.toString() === b.toString();\n    }\n    // Fallback on the method\n    return undefined;\n  });\n\nfunction useDeepCompareMemoize(value: Readonly<any>) {\n  const ref = useRef<any>();\n\n  if (!isEqual(value, ref.current)) {\n    ref.current = value;\n  }\n\n  return ref.current;\n}\n\n/**\n * Accepts a function that contains imperative, possibly effectful code.\n *\n * This is the deepCompare version of the `React.useEffect` hooks (that is shallowed compare)\n *\n * @param effect Imperative function that can return a cleanup function\n * @param deps If present, effect will only activate if the values in the list change.\n *\n * @see https://gist.github.com/kentcdodds/fb8540a05c43faf636dd68647747b074#gistcomment-2830503\n */\nexport function useDeepCompareEffect<T>(effect: React.EffectCallback, deps: T) {\n  useEffect(effect, useDeepCompareMemoize(deps as Readonly<any>));\n}\n\nexport function useDeepCompareCallback<T extends (...args: any[]) => any>(callback: T, deps: readonly any[]) {\n  return useCallback(callback, useDeepCompareMemoize(deps));\n}\n","import { useCallback, useRef } from \"react\";\n\nfunction createAbortController() {\n  try {\n    return new AbortController();\n  } catch {\n    return undefined;\n  }\n}\n\nexport function useAbort() {\n  const instance = useRef(createAbortController());\n\n  const abort = useCallback(() => {\n    if (instance && instance.current) {\n      instance.current.abort();\n      instance.current = createAbortController();\n    }\n  }, [instance]);\n\n  return {\n    abort,\n    getAbortSignal() {\n      return instance?.current?.signal;\n    },\n  };\n}\n","import { useContext, useState, useCallback, useEffect } from \"react\";\nimport { Cancelable, DebounceSettings } from \"lodash\";\nimport debounce from \"lodash/debounce\";\nimport merge from \"lodash/merge\";\nimport { IStringifyOptions } from \"qs\";\n\nimport { Context, RestfulReactProviderProps } from \"./Context\";\nimport { GetState } from \"./Get\";\nimport { processResponse } from \"./util/processResponse\";\nimport { useDeepCompareCallback } from \"./util/useDeepCompareEffect\";\nimport { useAbort } from \"./useAbort\";\nimport { constructUrl } from \"./util/constructUrl\";\nimport { parseError } from \"./util/parseError\";\n\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\nexport interface UseGetProps<TData, TError, TQueryParams, TPathParams> {\n  /**\n   * The path at which to request data,\n   * typically composed by parent Gets or the RestfulProvider.\n   */\n  path: string | ((pathParams: TPathParams) => string);\n  /**\n   * Path Parameters\n   */\n  pathParams?: TPathParams;\n  /** Options passed into the fetch call. */\n  requestOptions?: RestfulReactProviderProps[\"requestOptions\"];\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Query parameter stringify options\n   */\n  queryParamStringifyOptions?: IStringifyOptions;\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: (data: any) => TData;\n  /**\n   * Developer mode\n   * Override the state with some mocks values and avoid to fetch\n   */\n  mock?: { data?: TData; error?: TError; loading?: boolean; response?: Response };\n  /**\n   * Should we fetch data at a later stage?\n   */\n  lazy?: boolean;\n  /**\n   * An escape hatch and an alternative to `path` when you'd like\n   * to fetch from an entirely different URL.\n   *\n   */\n  base?: string;\n  /**\n   * How long do we wait between subsequent requests?\n   * Uses [lodash's debounce](https://lodash.com/docs/4.17.10#debounce) under the hood.\n   */\n  debounce?:\n    | {\n        wait?: number;\n        options: DebounceSettings;\n      }\n    | boolean\n    | number;\n}\n\ntype FetchData<TData, TError, TQueryParams, PathParams = unknown> = (\n  props: UseGetProps<TData, TError, TQueryParams, PathParams>,\n  context: RestfulReactProviderProps,\n  abort: () => void,\n  getAbortSignal: () => AbortSignal | undefined,\n) => Promise<void>;\ntype CancellableFetchData<TData, TError, TQueryParams, TPathParams> =\n  | FetchData<TData, TError, TQueryParams, TPathParams>\n  | (FetchData<TData, TError, TQueryParams, TPathParams> & Cancelable);\ntype RefetchOptions<TData, TError, TQueryParams, TPathParams> = Partial<\n  Omit<UseGetProps<TData, TError, TQueryParams, TPathParams>, \"lazy\">\n>;\n\nconst isCancellable = <T extends (...args: any[]) => any>(func: T): func is T & Cancelable => {\n  return typeof (func as any).cancel === \"function\" && typeof (func as any).flush === \"function\";\n};\n\nexport interface UseGetReturn<TData, TError, TQueryParams = {}, TPathParams = unknown> extends GetState<TData, TError> {\n  /**\n   * Absolute path resolved from `base` and `path` (context & local)\n   */\n  absolutePath: string;\n  /**\n   * Cancel the current fetch\n   */\n  cancel: () => void;\n  /**\n   * Refetch\n   */\n  refetch: (options?: RefetchOptions<TData, TError, TQueryParams, TPathParams>) => Promise<TData | null>;\n}\n\nexport function useGet<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>(\n  path: UseGetProps<TData, TError, TQueryParams, TPathParams>[\"path\"],\n  props?: Omit<UseGetProps<TData, TError, TQueryParams, TPathParams>, \"path\">,\n): UseGetReturn<TData, TError, TQueryParams>;\n\nexport function useGet<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>(\n  props: UseGetProps<TData, TError, TQueryParams, TPathParams>,\n): UseGetReturn<TData, TError, TQueryParams>;\n\nexport function useGet<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>() {\n  const props: UseGetProps<TData, TError, TQueryParams, TPathParams> =\n    typeof arguments[0] === \"object\" ? arguments[0] : { ...arguments[1], path: arguments[0] };\n\n  const context = useContext(Context);\n  const { path, pathParams = {} } = props;\n\n  const [state, setState] = useState<GetState<TData, TError>>({\n    data: null,\n    response: null,\n    loading: !props.lazy,\n    error: null,\n  });\n\n  const { abort, getAbortSignal } = useAbort();\n\n  const pathStr = typeof path === \"function\" ? path(pathParams as TPathParams) : path;\n\n  const _fetchData = useDeepCompareCallback<FetchData<TData, TError, TQueryParams, TPathParams>>(\n    async (props, context, abort, getAbortSignal) => {\n      const {\n        base = context.base,\n        path,\n        resolve = context.resolve || ((d: any) => d as TData),\n        queryParams = {},\n        queryParamStringifyOptions = {},\n        requestOptions,\n        pathParams = {},\n      } = props;\n\n      setState(prev => {\n        if (prev.error || !prev.loading) {\n          return { ...prev, error: null, loading: true };\n        }\n        return prev;\n      });\n\n      const pathStr = typeof path === \"function\" ? path(pathParams as TPathParams) : path;\n\n      const url = constructUrl(\n        base,\n        pathStr,\n        { ...context.queryParams, ...queryParams },\n        {\n          queryParamOptions: { ...context.queryParamStringifyOptions, ...queryParamStringifyOptions },\n        },\n      );\n\n      const propsRequestOptions =\n        (typeof requestOptions === \"function\" ? await requestOptions(url, \"GET\") : requestOptions) || {};\n\n      const contextRequestOptions =\n        (typeof context.requestOptions === \"function\"\n          ? await context.requestOptions(url, \"GET\")\n          : context.requestOptions) || {};\n\n      const signal = getAbortSignal();\n\n      const request = new Request(url, merge({}, contextRequestOptions, propsRequestOptions, { signal }));\n      if (context.onRequest) context.onRequest(request);\n\n      try {\n        const response = await fetch(request);\n        const originalResponse = response.clone();\n        if (context.onResponse) context.onResponse(originalResponse);\n        const { data, responseError } = await processResponse(response);\n\n        if (signal && signal.aborted) {\n          return;\n        }\n\n        if (!response.ok || responseError) {\n          const error = {\n            message: `Failed to fetch: ${response.status} ${response.statusText}${responseError ? \" - \" + data : \"\"}`,\n            data,\n            status: response.status,\n          };\n\n          setState(prev => ({\n            ...prev,\n            loading: false,\n            data: null,\n            error,\n            response: originalResponse,\n          }));\n\n          if (!props.localErrorOnly && context.onError) {\n            context.onError(error, () => _fetchData(props, context, abort, getAbortSignal), response);\n          }\n          return;\n        }\n\n        const resolvedData = resolve(data);\n        setState(prev => ({\n          ...prev,\n          error: null,\n          loading: false,\n          data: resolvedData,\n          response: originalResponse,\n        }));\n        return resolvedData;\n      } catch (e) {\n        // avoid state updates when component has been unmounted\n        // and when fetch/processResponse threw an error\n        if (signal && signal.aborted) {\n          return;\n        }\n\n        const error = parseError(e);\n\n        setState(prev => ({\n          ...prev,\n          data: null,\n          loading: false,\n          error,\n        }));\n\n        if (!props.localErrorOnly && context.onError) {\n          context.onError(error, () => _fetchData(props, context, abort, getAbortSignal));\n        }\n\n        return;\n      }\n    },\n    [\n      props.lazy,\n      props.mock,\n      props.path,\n      props.base,\n      props.resolve,\n      props.queryParams,\n      props.requestOptions,\n      props.pathParams,\n      context.base,\n      context.parentPath,\n      context.queryParams,\n      context.requestOptions,\n      abort,\n    ],\n  );\n  const fetchData = useCallback<CancellableFetchData<TData, TError, TQueryParams, TPathParams>>(\n    typeof props.debounce === \"object\"\n      ? debounce<FetchData<TData, TError, TQueryParams, TPathParams>>(\n          _fetchData,\n          props.debounce.wait,\n          props.debounce.options,\n        )\n      : typeof props.debounce === \"number\"\n      ? debounce<FetchData<TData, TError, TQueryParams, TPathParams>>(_fetchData, props.debounce)\n      : props.debounce\n      ? debounce<FetchData<TData, TError, TQueryParams, TPathParams>>(_fetchData)\n      : _fetchData,\n    [_fetchData, props.debounce],\n  );\n\n  useEffect(() => {\n    if (!props.lazy && !props.mock) {\n      fetchData(props, context, abort, getAbortSignal);\n    }\n\n    return () => {\n      if (isCancellable(fetchData)) {\n        fetchData.cancel();\n      }\n      abort();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [fetchData, props.lazy, props.mock]);\n\n  const refetch = useCallback(\n    (options: RefetchOptions<TData, TError, TQueryParams, TPathParams> = {}) =>\n      fetchData({ ...props, ...options }, context, abort, getAbortSignal),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [fetchData],\n  );\n\n  return {\n    ...state,\n    ...props.mock, // override the state\n    absolutePath: constructUrl(\n      props.base || context.base,\n      pathStr,\n      {\n        ...context.queryParams,\n        ...props.queryParams,\n      },\n      {\n        queryParamOptions: {\n          ...context.queryParamStringifyOptions,\n          ...props.queryParamStringifyOptions,\n        },\n      },\n    ),\n    cancel: () => {\n      setState({\n        ...state,\n        loading: false,\n      });\n      abort();\n    },\n    refetch,\n  };\n}\n","import merge from \"lodash/merge\";\nimport { useContext, useEffect, useState } from \"react\";\nimport { Context } from \"./Context\";\nimport { MutateMethod, MutateState, MutateRequestOptions } from \"./Mutate\";\nimport { Omit, UseGetProps } from \"./useGet\";\nimport { constructUrl } from \"./util/constructUrl\";\nimport { processResponse } from \"./util/processResponse\";\nimport { useAbort } from \"./useAbort\";\nimport { useDeepCompareCallback, useDeepCompareEffect } from \"./util/useDeepCompareEffect\";\nimport { getErrorMessage } from \"./util/parseError\";\n\nexport interface UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>\n  extends Omit<UseGetProps<TData, TError, TQueryParams, TPathParams>, \"lazy\" | \"debounce\" | \"mock\"> {\n  /**\n   * What HTTP verb are we using?\n   */\n  verb: \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n  /**\n   * Callback called after the mutation is done.\n   *\n   * @param body - Body given to mutate\n   * @param data - Response data\n   */\n  onMutate?: (body: TRequestBody, data: TData) => void;\n  /**\n   * Developer mode\n   * Override the state with some mocks values and avoid to fetch\n   */\n  mock?: {\n    mutate?: MutateMethod<TData, TRequestBody, TQueryParams, TPathParams>;\n    loading?: boolean;\n  };\n  /**\n   * A function to encode body of DELETE requests when appending it\n   * to an existing path\n   */\n  pathInlineBodyEncode?: typeof encodeURIComponent;\n}\n\nexport interface UseMutateReturn<TData, TError, TRequestBody, TQueryParams, TPathParams>\n  extends MutateState<TData, TError> {\n  /**\n   * Cancel the current fetch\n   */\n  cancel: () => void;\n  /**\n   * Call the mutate endpoint\n   */\n  mutate: MutateMethod<TData, TRequestBody, TQueryParams, TPathParams>;\n}\n\nexport function useMutate<\n  TData = any,\n  TError = any,\n  TQueryParams = { [key: string]: any },\n  TRequestBody = any,\n  TPathParams = unknown\n>(\n  props: UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>,\n): UseMutateReturn<TData, TError, TRequestBody, TQueryParams, TPathParams>;\n\nexport function useMutate<\n  TData = any,\n  TError = any,\n  TQueryParams = { [key: string]: any },\n  TRequestBody = any,\n  TPathParams = unknown\n>(\n  verb: UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>[\"verb\"],\n  path: UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>[\"path\"],\n  props?: Omit<UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>, \"path\" | \"verb\">,\n): UseMutateReturn<TData, TError, TRequestBody, TQueryParams, TPathParams>;\n\nexport function useMutate<\n  TData = any,\n  TError = any,\n  TQueryParams = { [key: string]: any },\n  TRequestBody = any,\n  TPathParams = unknown\n>(): UseMutateReturn<TData, TError, TRequestBody, TQueryParams, TPathParams> {\n  const props: UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams> =\n    typeof arguments[0] === \"object\" ? arguments[0] : { ...arguments[2], path: arguments[1], verb: arguments[0] };\n\n  const context = useContext(Context);\n  const {\n    verb,\n    base = context.base,\n    path,\n    queryParams = EMPTY_OBJECT,\n    resolve = context.resolve,\n    pathParams = EMPTY_OBJECT,\n  } = props;\n  const isDelete = verb === \"DELETE\";\n\n  const [state, setState] = useState<MutateState<TData, TError>>({\n    error: null,\n    loading: false,\n  });\n\n  const { abort, getAbortSignal } = useAbort();\n\n  // Cancel the fetch on unmount\n  useEffect(() => () => abort(), [abort]);\n\n  const { pathInlineBodyEncode, queryParamStringifyOptions, requestOptions, localErrorOnly, onMutate } = props;\n\n  const effectDependencies = [\n    path,\n    pathParams,\n    queryParams,\n    verb,\n    isDelete,\n    base,\n    context,\n    queryParamStringifyOptions,\n    requestOptions,\n    onMutate,\n    abort,\n    pathInlineBodyEncode,\n    localErrorOnly,\n    resolve,\n  ];\n  const mutate = useDeepCompareCallback<MutateMethod<TData, TRequestBody, TQueryParams, TPathParams>>(\n    async (body: TRequestBody, mutateRequestOptions?: MutateRequestOptions<TQueryParams, TPathParams>) => {\n      const signal = getAbortSignal();\n\n      setState(prevState => {\n        if (prevState.error || !prevState.loading) {\n          return { ...prevState, loading: true, error: null };\n        }\n        return prevState;\n      });\n\n      const pathStr =\n        typeof path === \"function\" ? path(mutateRequestOptions?.pathParams || (pathParams as TPathParams)) : path;\n\n      const pathParts = [pathStr];\n\n      const options: RequestInit = {\n        method: verb,\n      };\n\n      // don't set content-type when body is of type FormData\n      if (!(body instanceof FormData)) {\n        options.headers = { \"content-type\": typeof body === \"object\" ? \"application/json\" : \"text/plain\" };\n      }\n\n      if (body instanceof FormData) {\n        options.body = body;\n      } else if (typeof body === \"object\") {\n        options.body = JSON.stringify(body);\n      } else if (isDelete && body !== undefined) {\n        const possiblyEncodedBody = pathInlineBodyEncode ? pathInlineBodyEncode(String(body)) : String(body);\n\n        pathParts.push(possiblyEncodedBody);\n      } else {\n        options.body = (body as unknown) as string;\n      }\n\n      const url = constructUrl(\n        base,\n        pathParts.join(\"/\"),\n        { ...context.queryParams, ...queryParams, ...mutateRequestOptions?.queryParams },\n        {\n          queryParamOptions: { ...context.queryParamStringifyOptions, ...queryParamStringifyOptions },\n        },\n      );\n\n      const propsRequestOptions =\n        (typeof requestOptions === \"function\" ? await requestOptions(url, verb, body) : requestOptions) || {};\n\n      const contextRequestOptions =\n        (typeof context.requestOptions === \"function\"\n          ? await context.requestOptions(url, verb, body)\n          : context.requestOptions) || {};\n\n      const request = new Request(\n        url,\n        merge({}, contextRequestOptions, options, propsRequestOptions, mutateRequestOptions, { signal }),\n      );\n      if (context.onRequest) context.onRequest(request);\n\n      let response: Response;\n      try {\n        response = await fetch(request);\n        if (context.onResponse) context.onResponse(response.clone());\n      } catch (e) {\n        const error = {\n          message: `Failed to fetch: ${getErrorMessage(e)}`,\n          data: \"\",\n        };\n        setState({\n          error,\n          loading: false,\n        });\n\n        if (!localErrorOnly && context.onError) {\n          context.onError(error, () => mutate(body, mutateRequestOptions));\n        }\n\n        throw error;\n      }\n\n      const { data: rawData, responseError } = await processResponse(response);\n\n      let data: TData | any; // `any` -> data in error case\n      try {\n        data = resolve ? resolve(rawData) : rawData;\n      } catch (e) {\n        // avoid state updates when component has been unmounted\n        // and when fetch/processResponse threw an error\n        if (signal && signal.aborted) {\n          return;\n        }\n\n        const error = {\n          data: getErrorMessage(e),\n          message: `Failed to resolve: ${getErrorMessage(e)}`,\n        };\n\n        setState(prevState => ({\n          ...prevState,\n          error,\n          loading: false,\n        }));\n        throw e;\n      }\n\n      if (signal && signal.aborted) {\n        return;\n      }\n\n      if (!response.ok || responseError) {\n        const error = {\n          data,\n          message: `Failed to fetch: ${response.status} ${response.statusText}`,\n          status: response.status,\n        };\n\n        setState(prevState => ({\n          ...prevState,\n          error,\n          loading: false,\n        }));\n\n        if (!localErrorOnly && context.onError) {\n          context.onError(error, () => mutate(body), response);\n        }\n\n        throw error;\n      }\n\n      setState(prevState => ({ ...prevState, loading: false }));\n\n      if (onMutate) {\n        onMutate(body, data);\n      }\n\n      return data;\n    },\n    effectDependencies,\n  );\n  useDeepCompareEffect(() => {\n    if (state.loading) {\n      abort();\n    }\n  }, effectDependencies);\n\n  return {\n    ...state,\n    mutate,\n    ...props.mock,\n    cancel: () => {\n      setState(prevState => ({\n        ...prevState,\n        loading: false,\n      }));\n      abort();\n    },\n  };\n}\n\n// Declaring this in order to have a thing with stable identity\nconst EMPTY_OBJECT = {};\n"],"names":["runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","defineProperty","obj","key","desc","value","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","makeInvokeMethod","tryCatch","fn","arg","type","call","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","method","_invoke","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","record","result","__await","then","unwrapped","error","state","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","val","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","React","base","parentPath","data","requestOptions","onError","noop","onRequest","onResponse","queryParams","queryParamStringifyOptions","children","RestfulReactProvider","render","props","Provider","RestfulReactConsumer","Consumer","composeUrl","path","composedPath","composePath","startsWith","endsWith","url","parseError","e","message","parseErrorMessage","errMessage","getErrorMessage","processResponse","response","status","responseError","headers","get","includes","json","text","resolveData","resolvedData","resolveError","resolvedDataOrPromise","JSON","stringify","constructUrl","resolvePathOptions","queryParamOptions","stripTrailingSlash","normalizedBase","trimmedPath","encodedPathWithParams","qs","composed","Boolean","ContextlessGet","AbortController","_this","abortController","signal","loading","lazy","extraOptions","extraHeaders","options","Headers","requestPath","thisRequestOptions","__internal_hasExplicitBase","setState","makeRequestPath","concatPath","Request","getRequestOptions","request","fetch","originalResponse","clone","aborted","ok","statusText","localErrorOnly","resolved","debounce","wait","componentDidMount","componentDidUpdate","prevProps","isEqual","toString","componentWillUnmount","abort","refetch","absolutePath","Get","contextProps","unresolvedData","ContextlessPoll","previousData","lastResponse","polling","finished","nextData","equal","keepPolling","until","interval","lastPollIndex","Prefer","isResponseOk","isModified","prevState","resolvePromise","setTimeout","cycle","start","meta","states","actions","ContextlessMutate","body","mutateRequestOptions","verb","providerRequestOptions","pathInlineBodyEncode","pathWithPossibleBody","FormData","has","set","mutate","rawData","onMutate","useDeepCompareMemoize","ref","useRef","isEqualWith","current","a","b","useDeepCompareEffect","effect","deps","useEffect","useDeepCompareCallback","callback","useCallback","createAbortController","useAbort","instance","getAbortSignal","_instance$current","isCancellable","func","cancel","flush","EMPTY_OBJECT","contextRequestOptions","merge","arguments","useContext","pathParams","useState","pathStr","_fetchData","d","propsRequestOptions","mock","fetchData","isDelete","effectDependencies","pathParts","possiblyEncodedBody","String","join"],"mappings":"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"}